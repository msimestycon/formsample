# Azure DevOps Pipeline - Build Deployment Package (Offline)
# Equivalent to GitHub Actions workflow: build-deployment-package.yml
#
# IMPORTANT: This pipeline commits back to the repository to update package.json versions.
# Required permissions:
#   1. Go to Project Settings ‚Üí Repositories ‚Üí [Your Repo] ‚Üí Security
#   2. Find "Project Collection Build Service (your-org)"
#   3. Grant "Contribute" permission (Allow)
#   4. Grant "Create branch" permission (Allow) if needed
#
# Without these permissions, the pipeline will build successfully but won't update versions.

trigger:
  branches:
    include:
      - main
      - release/*
  paths:
    include:
      - '*/src/**'           # Changes in source of any form
      - '*/package.json'     # Changes in package.json of forms
      - 'build-form.js'      # Changes in shared build script

pr: none

parameters:
  - name: packageVersion
    displayName: 'Package version (manual trigger only, e.g., 1.0.0)'
    type: string
    default: '1.0.0'
  - name: releaseNotes
    displayName: 'Release notes (optional, will use commit message if empty)'
    type: string
    default: ''

variables:
  - name: formsChanged
    value: ''
  - name: hasChanges
    value: 'false'

pool:
  vmImage: 'ubuntu-latest'

stages:
  - stage: Build
    displayName: 'Build Deployment Package'
    jobs:
      - job: BuildForms
        displayName: 'Build Changed Forms'
        steps:
          - checkout: self
            fetchDepth: 0
            persistCredentials: true

          - task: NodeTool@0
            displayName: 'Setup Node.js'
            inputs:
              versionSpec: '18.x'

          - script: npm install
            displayName: 'Install root dependencies'

          - task: Bash@3
            name: BuildMetadata
            displayName: 'Get build metadata'
            inputs:
              targetType: 'inline'
              script: |
                COMMIT_HASH="$(Build.SourceVersion)"
                SHORT_HASH="${COMMIT_HASH:0:7}"
                BUILD_DATE="$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")"

                echo "##vso[task.setvariable variable=commitHash;isOutput=true]$COMMIT_HASH"
                echo "##vso[task.setvariable variable=shortHash;isOutput=true]$SHORT_HASH"
                echo "##vso[task.setvariable variable=buildDate;isOutput=true]$BUILD_DATE"

                echo "üîñ Commit: $SHORT_HASH"
                echo "üìÖ Build Date: $BUILD_DATE"

          - task: Bash@3
            name: ChangedForms
            displayName: 'Detect changed forms'
            inputs:
              targetType: 'inline'
              script: |
                echo "üîç Detecting changed forms..."

                # Manual trigger vs automatic
                if [ "$(Build.Reason)" = "Manual" ]; then
                  echo "üì¶ Manual trigger detected - building all forms"
                  CHANGED_FORMS=$(find . -type f -name "package.json" -not -path "*/node_modules/*" -not -path "./package.json" | xargs dirname | xargs -n1 basename)
                else
                  echo "üîç Analyzing changes from commits..."

                  # Get changed files between commits
                  CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || git ls-tree --name-only -r HEAD)

                  # Filter only changes in forms (src/ or package.json)
                  CHANGED_FORMS=$(echo "$CHANGED_FILES" | grep -E '^[^/]+/(src/|package\.json)' | cut -d'/' -f1 | sort -u || true)

                  if [ -z "$CHANGED_FORMS" ]; then
                    echo "‚ö†Ô∏è No form changes detected"
                    CHANGED_FORMS="NONE"
                  fi
                fi

                # Save result
                if [ "$CHANGED_FORMS" = "NONE" ]; then
                  echo "##vso[task.setvariable variable=hasChanges;isOutput=true]false"
                  echo "##vso[task.setvariable variable=formsChanged;isOutput=true]"
                  echo "üî¥ No forms to build - skipping build steps"
                else
                  echo "##vso[task.setvariable variable=hasChanges;isOutput=true]true"
                  FORMS_ARRAY=$(echo "$CHANGED_FORMS" | tr '\n' ' ')
                  echo "##vso[task.setvariable variable=formsChanged;isOutput=true]$FORMS_ARRAY"

                  echo "üìù Forms to build:"
                  echo "$CHANGED_FORMS"
                fi

          - task: Bash@3
            displayName: 'Calculate per-form versions (auto-increment)'
            condition: eq(variables['ChangedForms.hasChanges'], 'true')
            inputs:
              targetType: 'inline'
              script: |
                echo "üî¢ Incrementing versions for each changed form..."
                echo ""

                CHANGED_FORMS="$(ChangedForms.formsChanged)"

                for form_name in $CHANGED_FORMS; do
                  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                  echo "üì¶ Processing: $form_name"
                  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

                  if [ ! -f "$form_name/package.json" ]; then
                    echo "‚ùå ERROR: package.json not found for $form_name"
                    exit 1
                  fi

                  # Current version
                  CURRENT_VERSION=$(jq -r '.version // "1.0.0"' "$form_name/package.json")
                  echo "üìÑ Current version: $CURRENT_VERSION"

                  # Previous version
                  PREVIOUS_VERSION=$(git show HEAD~1:"$form_name/package.json" 2>/dev/null | jq -r '.version // "0.0.0"' 2>/dev/null || echo "0.0.0")
                  echo "üìú Previous version: $PREVIOUS_VERSION"

                  # Auto-increment PATCH
                  IFS='.' read -r MAJOR MINOR PATCH <<< "$PREVIOUS_VERSION"

                  if [ "$PREVIOUS_VERSION" = "0.0.0" ]; then
                    NEW_VERSION="1.0.0"
                    echo "üéâ First deployment! Starting at v1.0.0"
                  else
                    PATCH=$((PATCH + 1))
                    NEW_VERSION="$MAJOR.$MINOR.$PATCH"
                    echo "üîº Auto-increment: $PREVIOUS_VERSION ‚Üí $NEW_VERSION"
                  fi

                  echo ""

                  # Update package.json
                  echo "üíæ Updating $form_name/package.json to version $NEW_VERSION..."
                  jq --arg version "$NEW_VERSION" '.version = $version' "$form_name/package.json" > "$form_name/package.tmp.json"
                  mv "$form_name/package.tmp.json" "$form_name/package.json"

                  echo "‚úÖ package.json updated"
                  echo ""
                done

                echo "‚úÖ All form versions incremented"

          - task: Bash@3
            displayName: 'Build changed forms'
            condition: eq(variables['ChangedForms.hasChanges'], 'true')
            inputs:
              targetType: 'inline'
              script: |
                echo "üî® Building forms..."

                FORMS_TO_BUILD="$(ChangedForms.formsChanged)"

                for form_name in $FORMS_TO_BUILD; do
                  if [ -d "$form_name" ] && [ -f "$form_name/package.json" ]; then
                    echo "  üìù Building: $form_name"
                    cd "$form_name"

                    if npm run | grep -q "build"; then
                      npm run build

                      if [ -f "dist/form.js" ]; then
                        echo "  ‚úÖ Built successfully: $form_name ($(wc -c < dist/form.js) bytes)"
                      else
                        echo "  ‚ùå Build failed: $form_name (no dist/form.js)"
                        exit 1
                      fi
                    else
                      echo "  ‚ö†Ô∏è No build script found for: $form_name"
                    fi

                    cd ..
                  fi
                done

          - task: Bash@3
            displayName: 'Extract release notes'
            condition: eq(variables['ChangedForms.hasChanges'], 'true')
            inputs:
              targetType: 'inline'
              script: |
                echo "üìù Extracting release notes..."

                # Manual input or commit message
                if [ -n "${{ parameters.releaseNotes }}" ]; then
                  RELEASE_NOTES="${{ parameters.releaseNotes }}"
                  echo "‚ÑπÔ∏è Using manual release notes"
                else
                  COMMIT_MESSAGE=$(git log -1 --pretty=format:"%B")

                  if echo "$COMMIT_MESSAGE" | grep -q "^feat:\|^fix:\|^chore:\|^docs:\|^refactor:\|^perf:\|^test:"; then
                    RELEASE_NOTES=$(echo "$COMMIT_MESSAGE" | tail -n +2 | sed '/^$/d')

                    if [ -z "$RELEASE_NOTES" ]; then
                      RELEASE_NOTES=$(echo "$COMMIT_MESSAGE" | head -n 1)
                    fi
                  else
                    RELEASE_NOTES="$COMMIT_MESSAGE"
                  fi

                  if [ -z "$RELEASE_NOTES" ]; then
                    RELEASE_NOTES="Build autom√°tico - Pipeline #$(Build.BuildNumber)"
                  fi
                fi

                echo "$RELEASE_NOTES" > /tmp/release_notes.txt
                echo "‚úÖ Release notes extracted"

          - task: Bash@3
            displayName: 'Generate manifest.json'
            condition: eq(variables['ChangedForms.hasChanges'], 'true')
            inputs:
              targetType: 'inline'
              script: |
                echo "üìã Generating manifest.json..."

                PACKAGE_VERSION="1.0.$(date +%Y%m%d%H%M)"
                SHORT_HASH="$(BuildMetadata.shortHash)"
                BUILD_DATE="$(BuildMetadata.buildDate)"
                COMMIT_HASH="$(BuildMetadata.commitHash)"

                cat > manifest.json << EOF
                {
                  "packageVersion": "$PACKAGE_VERSION",
                  "buildDate": "$BUILD_DATE",
                  "commitHash": "$COMMIT_HASH",
                  "commitShortHash": "$SHORT_HASH",
                  "repositoryUrl": "$(Build.Repository.Uri)",
                  "buildUrl": "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)",
                  "forms": [
                EOF

                RELEASE_NOTES=$(cat /tmp/release_notes.txt)
                FORMS_TO_MANIFEST="$(ChangedForms.formsChanged)"
                first=true

                for form_name in $FORMS_TO_MANIFEST; do
                  if [ -d "$form_name" ] && [ -f "$form_name/package.json" ] && [ -f "$form_name/dist/form.js" ]; then
                    version=$(jq -r '.version // "1.0.0"' "$form_name/package.json")
                    description=$(jq -r '.description // "Custom form"' "$form_name/package.json")
                    author=$(jq -r '.author // "Bizuit Team"' "$form_name/package.json")
                    process_name=$(echo "$form_name" | sed -r 's/(^|-)([a-z])/\U\2/g')
                    size=$(wc -c < "$form_name/dist/form.js")
                    release_notes_json=$(echo "$RELEASE_NOTES" | jq -Rs .)

                    if [ "$first" = false ]; then
                      echo "," >> manifest.json
                    fi
                    first=false

                    cat >> manifest.json << FORM_EOF
                    {
                      "formName": "$form_name",
                      "processName": "$process_name",
                      "version": "$version",
                      "gitTag": "${form_name}-v${version}",
                      "author": "$author",
                      "description": "$description",
                      "sizeBytes": $size,
                      "path": "forms/$form_name/form.js",
                      "releaseNotes": $release_notes_json
                    }
                FORM_EOF
                  fi
                done

                cat >> manifest.json << EOF
                  ]
                }
                EOF

                jq '.' manifest.json > manifest.tmp && mv manifest.tmp manifest.json
                echo "‚úÖ Manifest generated"

          - task: Bash@3
            displayName: 'Create deployment ZIPs (per form)'
            condition: eq(variables['ChangedForms.hasChanges'], 'true')
            inputs:
              targetType: 'inline'
              script: |
                echo "üì¶ Creating individual deployment ZIPs..."

                FORMS_TO_PACKAGE="$(ChangedForms.formsChanged)"
                SHORT_HASH="$(BuildMetadata.shortHash)"
                BUILD_DATE="$(BuildMetadata.buildDate)"
                COMMIT_HASH="$(BuildMetadata.commitHash)"

                for form_name in $FORMS_TO_PACKAGE; do
                  if [ -d "$form_name" ] && [ -f "$form_name/dist/form.js" ]; then
                    echo ""
                    echo "üìù Creating ZIP for: $form_name"

                    FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
                    echo "  Version: $FORM_VERSION"

                    mkdir -p "temp-package-$form_name"

                    # Create individual manifest
                    PACKAGE_VERSION="1.0.$(date +%Y%m%d%H%M)"
                    description=$(jq -r '.description // "Custom form"' "$form_name/package.json")
                    author=$(jq -r '.author // "Bizuit Team"' "$form_name/package.json")
                    process_name=$(echo "$form_name" | sed -r 's/(^|-)([a-z])/\U\2/g')
                    size=$(wc -c < "$form_name/dist/form.js")
                    RELEASE_NOTES=$(cat /tmp/release_notes.txt 2>/dev/null || echo "Deployment package")
                    release_notes_json=$(echo "$RELEASE_NOTES" | jq -Rs .)

                    jq -n \
                      --arg packageVersion "$PACKAGE_VERSION" \
                      --arg buildDate "$BUILD_DATE" \
                      --arg commitHash "$COMMIT_HASH" \
                      --arg commitShortHash "$SHORT_HASH" \
                      --arg repositoryUrl "$(Build.Repository.Uri)" \
                      --arg buildUrl "$(System.TeamFoundationCollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)" \
                      --arg formName "$form_name" \
                      --arg processName "$process_name" \
                      --arg version "$FORM_VERSION" \
                      --arg gitTag "${form_name}-v${FORM_VERSION}" \
                      --arg description "$description" \
                      --arg author "$author" \
                      --argjson releaseNotes "$release_notes_json" \
                      --arg sizeBytes "$size" \
                      --arg path "forms/$form_name/form.js" \
                      '{
                        packageVersion: $packageVersion,
                        buildDate: $buildDate,
                        commitHash: $commitHash,
                        commitShortHash: $commitShortHash,
                        repositoryUrl: $repositoryUrl,
                        buildUrl: $buildUrl,
                        forms: [
                          {
                            formName: $formName,
                            processName: $processName,
                            version: $version,
                            gitTag: $gitTag,
                            description: $description,
                            author: $author,
                            releaseNotes: $releaseNotes,
                            sizeBytes: ($sizeBytes | tonumber),
                            path: $path
                          }
                        ]
                      }' > "temp-package-$form_name/manifest.json"

                    # Copy form
                    mkdir -p "temp-package-$form_name/forms/$form_name"
                    cp "$form_name/dist/form.js" "temp-package-$form_name/forms/$form_name/"

                    # Create ZIP
                    PACKAGE_NAME="${form_name}-deployment-${FORM_VERSION}-${SHORT_HASH}.zip"
                    cd "temp-package-$form_name"
                    zip -r "../$PACKAGE_NAME" .
                    cd ..

                    # Copy to upload directory
                    mkdir -p "$form_name/upload"
                    cp "$PACKAGE_NAME" "$form_name/upload/"

                    rm -rf "temp-package-$form_name"

                    echo "  ‚úÖ Created: $PACKAGE_NAME"
                  fi
                done

          - task: Bash@3
            displayName: 'Commit and push changes'
            condition: eq(variables['ChangedForms.hasChanges'], 'true')
            inputs:
              targetType: 'inline'
              script: |
                echo "üìù Committing deployment ZIPs and updated package.json..."

                git config user.name "Azure Pipelines"
                git config user.email "azure-pipelines@dev.azure.com"

                # Force add upload directory (it's in .gitignore but we need to commit ZIPs)
                git add -f */upload/*.zip || true
                git add -f */upload/ || true
                git add */package.json || true

                if git diff --staged --quiet; then
                  echo "‚ö†Ô∏è No changes to commit"
                else
                  FORMS_WITH_VERSIONS=""
                  CHANGED_FORMS="$(ChangedForms.formsChanged)"
                  for form_name in $CHANGED_FORMS; do
                    if [ -f "$form_name/package.json" ]; then
                      FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
                      FORMS_WITH_VERSIONS="${FORMS_WITH_VERSIONS}\n  - $form_name: v$FORM_VERSION"
                    fi
                  done

                  git commit -m "chore: update versions and add deployment ZIPs [skip ci]" \
                             -m "Generated by Azure Pipeline #$(Build.BuildNumber)" \
                             -m "Commit: $(BuildMetadata.commitHash)" \
                             -m "" \
                             -m "Updated forms:${FORMS_WITH_VERSIONS}" \
                             -m "" \
                             -m "ü§ñ Automated commit by Azure Pipelines"

                  echo "üì§ Pushing changes to repository..."

                  # Extract branch name from refs/heads/main -> main
                  BRANCH_NAME=$(echo "$(Build.SourceBranch)" | sed 's|refs/heads/||')
                  echo "Branch: $BRANCH_NAME"

                  # Push with explicit error handling
                  if git push origin HEAD:$BRANCH_NAME; then
                    echo "‚úÖ Changes committed and pushed successfully"
                  else
                    echo "‚ùå Failed to push changes"
                    echo "This might be a permissions issue. Check pipeline settings:"
                    echo "  - Project Settings ‚Üí Repositories ‚Üí Security"
                    echo "  - Grant 'Contribute' permission to Build Service"
                    exit 1
                  fi
                fi

          - task: Bash@3
            displayName: 'Prepare artifacts for upload'
            condition: eq(variables['ChangedForms.hasChanges'], 'true')
            inputs:
              targetType: 'inline'
              script: |
                echo "üì¶ Preparing artifacts directory..."
                mkdir -p $(Build.ArtifactStagingDirectory)

                # Copy only the deployment ZIPs to artifact staging
                CHANGED_FORMS="$(ChangedForms.formsChanged)"
                for form_name in $CHANGED_FORMS; do
                  if [ -d "$form_name/upload" ]; then
                    # Get the newest ZIP
                    ZIP_FILE=$(ls -t $form_name/upload/*.zip 2>/dev/null | head -1)
                    if [ -n "$ZIP_FILE" ]; then
                      cp "$ZIP_FILE" $(Build.ArtifactStagingDirectory)/
                      echo "  ‚úÖ Staged: $(basename $ZIP_FILE)"
                    fi
                  fi
                done

                echo ""
                echo "üìã Artifacts ready:"
                ls -lh $(Build.ArtifactStagingDirectory)/

          - task: PublishBuildArtifacts@1
            displayName: 'Publish deployment ZIPs as artifacts'
            condition: eq(variables['ChangedForms.hasChanges'], 'true')
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
              ArtifactName: 'deployment-packages'
              publishLocation: 'Container'

          - task: Bash@3
            displayName: 'Build Summary'
            condition: eq(variables['ChangedForms.hasChanges'], 'true')
            inputs:
              targetType: 'inline'
              script: |
                echo "## üéâ Deployment Package Built Successfully"
                echo ""
                echo "**Build Date**: $(BuildMetadata.buildDate)"
                echo "**Commit**: $(BuildMetadata.shortHash)"
                echo ""
                echo "### üì¶ Forms with Independent Versions"

                CHANGED_FORMS="$(ChangedForms.formsChanged)"
                for form_name in $CHANGED_FORMS; do
                  if [ -f "$form_name/package.json" ]; then
                    FORM_VERSION=$(jq -r '.version' "$form_name/package.json")
                    echo "- **$form_name**: v$FORM_VERSION"
                  fi
                done

                echo ""
                echo "### üì• Download"
                echo "Check pipeline artifacts to download deployment packages"

          - task: Bash@3
            displayName: 'No Changes Summary'
            condition: eq(variables['ChangedForms.hasChanges'], 'false')
            inputs:
              targetType: 'inline'
              script: |
                echo "## ‚ÑπÔ∏è No Forms Changed"
                echo ""
                echo "No form files were modified. No deployment packages were created."
